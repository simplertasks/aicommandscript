<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>AI.Web.Script Wizard</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@2/css/pico.min.css">
  <script src="https://unpkg.com/lucide@latest"></script>
</head>

<body>
  <main class="container">

    <nav>
      <ul>
        <li><strong>AI Quiz</strong></li>
      </ul>
      <ul>
        <li><a href="#" id="helpLink">Help</a></li>
        <li><a href="#" id="settingsLink">Settings</a></li>
        <li>
          <details class="dropdown">
            <summary role="button" aria-label="Toggle theme">
              <svg aria-hidden="true" focusable="false" role="img" xmlns="http://www.w3.org/2000/svg"
                viewBox="0 0 24 24" height="16px" fill="none" stroke="currentColor" stroke-width="2"
                stroke-linecap="round" stroke-linejoin="round">
                <circle cx="12" cy="12" r="5"></circle>
                <line x1="12" y1="1" x2="12" y2="3"></line>
                <line x1="12" y1="21" x2="12" y2="23"></line>
                <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                <line x1="1" y1="12" x2="3" y2="12"></line>
                <line x1="21" y1="12" x2="23" y2="12"></line>
                <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
              </svg>
            </summary>
            <ul>
              <li><a href="#" data-theme-switcher="light">Light</a></li>
              <li><a href="#" data-theme-switcher="dark">Dark</a></li>
              <li><a href="#" data-theme-switcher="auto">Auto</a></li>
            </ul>
          </details>
        </li>
      </ul>
    </nav>

    <!-- Menu content will be shown in Help modal -->
    <div id="menuContent" style="display:none;"></div>

    <!-- Wizard Navigation -->
    <article id="wizardNav" style="display:none;">
      <nav>
        <ul role="list" id="wizardSteps"></ul>
      </nav>
    </article>

    <!-- View Container -->
    <article id="viewContainer">
    </article>

    <!-- Navigation Buttons -->
    <article id="wizardButtons">
      <div role="group">
        <button class="secondary" id="homeBtn" onclick="wizard.goto(0)">
          <i data-lucide="home"></i> Home
        </button>
        <button class="secondary" id="prevBtn" onclick="wizard.prev()">
          <i data-lucide="chevron-left"></i> Back
        </button>
        <button id="nextBtn" onclick="wizard.next()">
          Forward <i data-lucide="chevron-right"></i>
        </button>
      </div>
    </article>

  </main>

  <!-- Help Modal -->
  <dialog id="helpModal">
    <article>
      <header>
        <button aria-label="Close" rel="prev"></button>
        <p><strong>Help</strong></p>
      </header>
      <div id="helpContent">
        <p><em>Loading help content...</em></p>
      </div>
    </article>
  </dialog>

  <!-- Settings Modal -->
  <dialog id="settingsModal">
    <article>
      <header>
        <button aria-label="Close" rel="prev"></button>
        <p><strong>Settings</strong></p>
      </header>
      <div id="settingsContent">
        <h3>Application Settings</h3>

        <form>
          <fieldset>
            <legend>AI Configuration</legend>
            <label>
              <input type="checkbox" id="useSimulatedAI" checked>
              Use simulated AI responses (recommended for testing)
            </label>
            <small>When enabled, the app will use pre-programmed responses instead of calling the Groq API.</small>
          </fieldset>

          <fieldset>
            <legend>Display Options</legend>
            <label>
              <input type="checkbox" id="showDebugInfo">
              Show debug information in console
            </label>
            <small>Enable this to see detailed logging information in the browser console.</small>
          </fieldset>

          <fieldset>
            <legend>Quiz Behavior</legend>
            <label>
              Auto-advance after form submission
              <select id="autoAdvance">
                <option value="true">Yes</option>
                <option value="false" selected>No</option>
              </select>
            </label>
            <small>Automatically move to the next step after submitting a form.</small>
          </fieldset>
        </form>

        <footer>
          <button type="button" onclick="saveSettings()">Save Settings</button>
          <button type="button" class="secondary" onclick="resetSettings()">Reset to Defaults</button>
        </footer>
      </div>
    </article>
  </dialog>

  <script src="https://cdn.jsdelivr.net/npm/marked@11.1.1/marked.min.js"></script>
  <script>
    // DEFAULT SCRIPT - stored as a JavaScript template literal
    const defaultScript = `AI.Web.Script - Structural Natural language instructions for AI to interpret

_________
METADATA

title: Cities Quiz
author: J. Smith
description: A simple quiz testing the knowledge of cities.

___________
AI-CONTEXT

system-prompt: You are an AI assistant helping to interpret and execute AI.Web.Script instructions. Follow all instructions precisely and provide only the requested output without any additional commentary.

____________
AI-GENERATED 

ai-selected-city: randomly select one city from [[cities]]

ai-evaluation: evaluate [[city-facts]] for accuracy and completeness
ai-grade: assign grade A-F with brief explanation
ai-funfact: generate interesting fact about [[ai-selected-city]]

_________
VIEWS

<view name="input">
# Welcome to [[title]] by [[author]]

[[description]]

<form>
  <label>Please enter your name
    <input type="text" name="user-name" placeholder="Your name" required />
  </label>
  
  <label>
    Groq API Key (optional - starts with <code>gsk_</code>)
    <input type="password" name="apiKey" placeholder="gsk_..." />
    <small>Leave blank to use simulated AI. Your API key is stored in browser memory only.</small>
  </label>
</form>
</view>

<view name="facts">
<form>
  <label>What are three facts about [[ai-selected-city]]?
    <textarea name="city-facts" rows="4" placeholder="Enter three facts..." required></textarea>
  </label>
</form>

</view>

<view name="output">

**Hello [[user-name]]!**

You were asked about **[[ai-selected-city]]** and you replied:

_[[city-facts]]_

## AI Evaluation
[[ai-evaluation]]

**Grade: [[ai-grade]]**

## Fun Fact
_[[ai-funfact]]_

</view>

<view name="goodbye">

## Thanks for playing [[title]]!

By the way, the other cities were:
[[cities]]

> Goodbye

</view>

____
DATA

cities:
- London, England
- New York City, USA
- Toronto, Canada
- Washington, D.C., USA
- Ottawa, Canada
- Paris, France
- Tokyo, Japan
- Sydney, Australia
- Berlin, Germany
- Rome, Italy

_____
MENU

<menu>

# Help

Welcome to the Cities Quiz! Here's how to use this application:

## Getting Started
1. Optionally enter your Groq API key for AI-powered evaluation
2. Click "Start Quiz" to begin
3. Enter your name when prompted
4. Answer the question about the selected city

## Tips
- Without an API key, the app uses simulated AI responses
- Try to provide three detailed facts about the city
- Click through all pages to see your results and fun facts

## Navigation
- Use the numbered buttons to jump between sections
- Use Home, Back, and Forward buttons at the bottom
- Click Restart on the final page to try again with a new city


# About [[title]]

**Version:** [[version]]  
**Author:** [[author]]

## About AI.Web.Script

This application is built using AI.Web.Script - a declarative language for creating AI-powered web applications.

### Features
- Natural language AI instructions
- Markdown-based views
- Variable substitution
- Multi-step wizard interface
- Optional AI integration via Groq API

### Links
- [GitHub Repository](https://github.com/yourusername/ai-web-script)
- [Documentation](https://docs.aiwebscript.dev)
- [Examples](https://examples.aiwebscript.dev)

### License
MIT License - Free to use and modify

</menu>`;

    const wizard = {
      script: null,
      currentStep: 0,
      context: {},
      views: [],
      apiKey: '',

      parseScript(src) {
        const script = {
          metadata: {},
          aiContext: {},
          aiGenerated: {},
          views: [],
          data: {},
          menu: ''
        };

        try {
          // Parse METADATA
          const metaMatch = src.match(/_+\s*METADATA\s+([\s\S]*?)_+/);
          if (metaMatch) {
            const lines = metaMatch[1].trim().split('\n');
            lines.forEach(line => {
              const match = line.match(/^(\w+):\s*(.+)$/);
              if (match) {
                script.metadata[match[1]] = match[2].trim();
              }
            });
          }

          // Parse AI-CONTEXT
          const contextMatch = src.match(/_+\s*AI-CONTEXT\s+([\s\S]*?)_+/);
          if (contextMatch) {
            const lines = contextMatch[1].trim().split('\n');
            lines.forEach(line => {
              const match = line.match(/^([\w-]+):\s*(.+)$/);
              if (match) {
                script.aiContext[match[1]] = match[2].trim();
              }
            });
          }

          // Parse AI-GENERATED
          const aiMatch = src.match(/_+\s*AI-GENERATED\s+([\s\S]*?)_+/);
          if (aiMatch) {
            const lines = aiMatch[1].trim().split('\n');
            lines.forEach(line => {
              const match = line.match(/^([\w-]+):\s*(.+)$/);
              if (match) {
                script.aiGenerated[match[1]] = match[2].trim();
              }
            });
          }

          // Parse VIEWS
          const viewMatches = src.matchAll(/<view name="([^"]+)">([\s\S]*?)<\/view>/gi);
          for (const match of viewMatches) {
            script.views.push({
              name: match[1],
              content: match[2].trim()
            });
          }

          // Parse DATA
          const dataMatch = src.match(/_+\s*DATA\s+([\s\S]*?)$/);
          if (dataMatch) {
            const dataText = dataMatch[1].trim();
            const currentKey = dataText.match(/^(\w+):/m);
            if (currentKey) {
              const key = currentKey[1];
              const items = [];
              const lines = dataText.split('\n');
              lines.forEach(line => {
                const itemMatch = line.match(/^-\s*(.+)$/);
                if (itemMatch) {
                  items.push(itemMatch[1].trim());
                }
              });
              script.data[key] = items;
            }
          }

          // Parse MENU
          const menuMatch = src.match(/_+\s*MENU\s+([\s\S]*?)$/);
          console.log('Menu match found:', menuMatch);
          if (menuMatch) {
            const menuContent = menuMatch[1].trim();
            console.log('Menu content section:', menuContent);
            const menuTagMatch = menuContent.match(/<menu>([\s\S]*?)<\/menu>/i);
            console.log('Menu tag match:', menuTagMatch);
            if (menuTagMatch) {
              script.menu = menuTagMatch[1].trim();
              console.log('Parsed menu content:', script.menu);
            }
          }
        } catch (error) {
          console.error('Parse error:', error);
          alert('Error parsing script: ' + error.message);
        }

        return script;
      },

      async init(scriptText) {
        try {
          this.script = this.parseScript(scriptText);
          this.views = this.script.views;
          this.currentStep = 0;
          this.context = {
            ...this.script.metadata,
            ...this.script.data
          };

          // Render menu content
          this.renderMenu();

          console.log('Parsed script:', this.script);
          console.log('Views found:', this.views.length);

          if (this.views.length === 0) {
            alert('No views found in script! Check the <view name="..."> tags.');
            return;
          }

          // Build and show wizard navigation immediately
          this.buildWizardSteps();
          document.getElementById('wizardNav').style.display = 'block';
          document.getElementById('wizardButtons').style.display = 'block';

          // Show the first view (input form)
          this.goto(0);
        } catch (error) {
          console.error('Init error:', error);
          alert('Error initializing wizard: ' + error.message);
        }
      },

      async startWizard() {
        try {
          await this.generateAI();
          // Navigation bar is already visible from init()

          // Move to the next view (facts)
          this.goto(1);
        } catch (error) {
          console.error('Start wizard error:', error);
          alert('Error starting wizard: ' + error.message);
        }
      },

      async callGroqAPI(prompt) {
        if (!this.apiKey || !this.apiKey.startsWith('gsk_')) {
          console.log('âš ï¸ No API key - using fallback');
          return null;
        }

        try {
          console.log('ðŸŒ Calling Groq API...');
          const systemPrompt = this.script.aiContext['system-prompt'] ||
            'You are a helpful AI assistant.';

          const response = await fetch('https://api.groq.com/openai/v1/chat/completions', {
            method: 'POST',
            headers: {
              'Authorization': `Bearer ${this.apiKey}`,
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              model: 'llama-3.1-8b-instant',
              messages: [
                {
                  role: 'system',
                  content: systemPrompt
                },
                {
                  role: 'user',
                  content: prompt
                }
              ],
              temperature: 0.7,
              max_tokens: 500
            })
          });

          if (!response.ok) {
            const errorText = await response.text();
            console.error('âŒ API Error:', response.status, errorText);
            throw new Error(`API returned ${response.status}`);
          }

          const result = await response.json();
          console.log('âœ… API Response received');
          return result?.choices?.[0]?.message?.content?.trim();
        } catch (error) {
          console.error('âŒ Groq API error:', error);
          alert(`API Error: ${error.message}\n\nFalling back to simulated AI.`);
          return null;
        }
      },

      async generateAI() {
        console.log('ðŸŽ¯ generateAI called with API key:', this.apiKey ? 'Present' : 'Missing');
        const cities = this.script.data.cities || [];
        console.log('ðŸ™ï¸ Available cities:', cities);

        if (cities.length > 0) {
          // Always set a city first as fallback
          this.context['ai-selected-city'] = cities[Math.floor(Math.random() * cities.length)];
          console.log('ðŸŽ² Fallback city set:', this.context['ai-selected-city']);

          // Try to get AI selection if API key is available
          if (this.apiKey && this.apiKey.startsWith('gsk_')) {
            const cityPrompt = `From this list, randomly select ONE city:\n${cities.join('\n')}\n\nRespond with ONLY the city name exactly as it appears in the list, nothing else.`;
            const selectedCity = await this.callGroqAPI(cityPrompt);
            console.log('ðŸ¤– API response for city selection:', selectedCity);

            if (selectedCity && cities.some(c => selectedCity.includes(c.split(',')[0]))) {
              this.context['ai-selected-city'] = cities.find(c => selectedCity.includes(c.split(',')[0]));
              console.log('âœ¨ AI selected city:', this.context['ai-selected-city']);
            }
          }
        }

        console.log('ðŸŽ¯ Final context after generateAI:', this.context);
      },

      buildWizardSteps() {
        const stepsContainer = document.getElementById('wizardSteps');
        stepsContainer.innerHTML = '';

        this.views.forEach((view, index) => {
          const li = document.createElement('li');
          const btn = document.createElement('button');
          btn.textContent = `${index + 1}. ${this.capitalize(view.name)}`;
          btn.className = index === 0 ? 'contrast' : 'secondary outline';
          btn.onclick = () => this.goto(index);
          li.appendChild(btn);
          stepsContainer.appendChild(li);
        });
      },

      goto(step) {
        if (step < 0 || step >= this.views.length) return;

        console.log('Going to step:', step);

        const stepButtons = document.querySelectorAll('#wizardSteps button');
        stepButtons.forEach((btn, index) => {
          if (index === step) {
            btn.className = 'contrast';
          } else if (index < step) {
            btn.className = 'secondary';
          } else {
            btn.className = 'secondary outline';
          }
        });

        this.currentStep = step;
        this.renderView(step);
        this.updateNavButtons();
      },

      renderView(index) {
        try {
          const view = this.views[index];
          let content = view.content;

          console.log('ðŸŽ¨ Rendering view:', view.name, 'at index:', index);
          console.log('ðŸŽ¨ Original content:', content);
          console.log('ðŸŽ¨ Current context:', this.context);

          content = this.replaceVariables(content);
          console.log('ðŸŽ¨ Content after variable replacement:', content);
          content = content.replace(/^\/\/.+$/gm, '');

          const container = document.getElementById('viewContainer');
          container.innerHTML = marked.parse(content);

          const form = container.querySelector('form');
          if (form) {
            form.onsubmit = (e) => {
              e.preventDefault();

              // If this is the first view (input), capture API key and start the wizard
              if (index === 0) {
                const formData = new FormData(form);
                this.apiKey = formData.get('apiKey') || '';

                // Capture all form data including user-name
                for (const [key, value] of formData.entries()) {
                  this.context[key] = value;
                  console.log('First view captured:', key, '=', value);
                }

                if (this.apiKey && this.apiKey.startsWith('gsk_')) {
                  console.log('ðŸ¤– Using Groq API');
                } else {
                  console.log('ðŸŽ­ Using simulated AI (no API key provided)');
                }

                console.log('Context after first view:', this.context);

                // Start the wizard
                this.startWizard();
              } else {
                this.next();
              }
            };
          }

          // Initialize Lucide icons after rendering
          lucide.createIcons();
        } catch (error) {
          console.error('Render error:', error);
          alert('Error rendering view: ' + error.message);
        }
      },

      replaceVariables(content) {
        return content.replace(/\[\[([^\]]+)\]\]/g, (match, key) => {
          console.log('Replacing variable:', key, 'with value:', this.context[key]);
          if (this.context[key] !== undefined) {
            if (Array.isArray(this.context[key])) {
              return this.formatArray(this.context[key]);
            }
            return this.context[key];
          }
          console.log('Variable not found:', key);
          return match;
        });
      },

      formatArray(arr) {
        const flags = {
          'England': 'ðŸ´ó §ó ¢ó ¥ó ®ó §ó ¿',
          'USA': 'ðŸ‡ºðŸ‡¸',
          'Canada': 'ðŸ‡¨ðŸ‡¦',
          'France': 'ðŸ‡«ðŸ‡·',
          'Japan': 'ðŸ‡¯ðŸ‡µ',
          'Australia': 'ðŸ‡¦ðŸ‡º',
          'Germany': 'ðŸ‡©ðŸ‡ª',
          'Italy': 'ðŸ‡®ðŸ‡¹'
        };

        return '\n' + arr.map((item, index) => {
          let flagged = item;
          Object.keys(flags).forEach(country => {
            if (item.includes(country)) {
              flagged = `${item} ${flags[country]}`;
            }
          });
          return `${index + 1}. ${flagged}`;
        }).join('\n') + '\n';
      },

      renderMenu() {
        console.log('renderMenu called, script.menu:', this.script.menu);
        if (!this.script.menu) {
          console.log('No menu content found');
          return;
        }

        try {
          let menuContent = this.script.menu;
          console.log('Original menu content:', menuContent);
          menuContent = this.replaceVariables(menuContent);
          console.log('After variable replacement:', menuContent);

          const menuContainer = document.getElementById('menuContent');
          console.log('Menu container found:', menuContainer);
          if (menuContainer) {
            const htmlContent = marked.parse(menuContent);
            console.log('Generated HTML:', htmlContent);
            menuContainer.innerHTML = htmlContent;
          }

          // Also update the help modal content
          this.updateHelpModal(menuContent);
        } catch (error) {
          console.error('Menu render error:', error);
        }
      },

      updateHelpModal(menuContent) {
        try {
          const helpContainer = document.getElementById('helpContent');
          if (helpContainer && menuContent) {
            const htmlContent = marked.parse(menuContent);
            helpContainer.innerHTML = htmlContent;
          }
        } catch (error) {
          console.error('Help modal update error:', error);
        }
      },

      async next() {
        try {
          console.log('Next clicked');
          const currentViewEl = document.getElementById('viewContainer');
          const form = currentViewEl.querySelector('form');

          if (form) {
            if (!form.checkValidity()) {
              form.reportValidity();
              return;
            }

            const formData = new FormData(form);
            for (const [key, value] of formData.entries()) {
              this.context[key] = value;
              console.log('Captured:', key, '=', value);
            }

            // If this is the first view (input), capture API key and start the wizard
            if (this.currentStep === 0) {
              this.apiKey = formData.get('apiKey') || '';

              if (this.apiKey && this.apiKey.startsWith('gsk_')) {
                console.log('ðŸ¤– Using Groq API');
              } else {
                console.log('ðŸŽ­ Using simulated AI (no API key provided)');
              }

              console.log('Context after first view:', this.context);

              // Start the wizard
              await this.startWizard();
              return; // startWizard() will handle the navigation
            }

            // Run AI evaluation when moving from facts view (index 1) to output view (index 2)
            if (this.currentStep === 1) {
              const nextBtn = document.getElementById('nextBtn');
              const originalHTML = nextBtn.innerHTML;
              nextBtn.innerHTML = '<i data-lucide="loader-2"></i> AI is thinking...';
              nextBtn.disabled = true;
              lucide.createIcons();

              await this.evaluateWithAI();

              nextBtn.innerHTML = originalHTML;
              nextBtn.disabled = false;
              lucide.createIcons();
            }
          }

          this.goto(this.currentStep + 1);
        } catch (error) {
          console.error('Next error:', error);
          alert('Error: ' + error.message);
        }
      },

      prev() {
        console.log('Prev clicked');
        this.goto(this.currentStep - 1);
      },

      async evaluateWithAI() {
        const facts = this.context['city-facts'] || '';
        const city = this.context['ai-selected-city'];

        const evalPrompt = `Evaluate these facts about ${city}:
"${facts}"

Provide:
1. A brief evaluation (1-2 sentences) on accuracy and completeness
2. A grade (A, B, C, D, or F)

Format your response as:
EVALUATION: [your evaluation]
GRADE: [letter grade only]`;

        const evalResponse = await this.callGroqAPI(evalPrompt);

        if (evalResponse) {
          const evalMatch = evalResponse.match(/EVALUATION:\s*(.+)/i);
          const gradeMatch = evalResponse.match(/GRADE:\s*([A-F])/i);

          this.context['ai-evaluation'] = evalMatch ? evalMatch[1].trim() : 'Good effort!';
          this.context['ai-grade'] = gradeMatch ? gradeMatch[1] : 'B';
          console.log('âœ¨ AI evaluation:', this.context['ai-evaluation']);
          console.log('âœ¨ AI grade:', this.context['ai-grade']);
          console.log('âœ¨ Full context after AI evaluation:', this.context);
        } else {
          const factCount = facts.split('.').filter(f => f.trim().length > 10).length;
          if (factCount >= 3) {
            this.context['ai-evaluation'] = 'Great job! You provided comprehensive information.';
            this.context['ai-grade'] = 'A';
          } else {
            this.context['ai-evaluation'] = 'Good effort, but could use more detail.';
            this.context['ai-grade'] = 'C';
          }
          console.log('ðŸŽ­ Simulated evaluation:', this.context['ai-evaluation']);
          console.log('ðŸŽ­ Simulated grade:', this.context['ai-grade']);
          console.log('ðŸŽ­ Full context after simulated evaluation:', this.context);
        }

        const factPrompt = `Provide ONE surprising or little-known fact about ${city}. Be specific and interesting. Respond with ONLY the fact, no introduction.`;
        const funFact = await this.callGroqAPI(factPrompt);

        if (funFact) {
          this.context['ai-funfact'] = funFact;
          console.log('âœ¨ AI fun fact:', funFact);
        } else {
          const funFacts = {
            'London, England': 'London has over 170 museums, more than any other city in the world!',
            'New York City, USA': 'New York City has a hidden network of abandoned subway stations.',
            'Toronto, Canada': 'Toronto has the longest street in the world - Yonge Street at 1,896 km.',
            'Paris, France': 'There is only one stop sign in the entire city of Paris!',
            'Tokyo, Japan': 'Tokyo has more neon signs than any other city in the world.',
            'Sydney, Australia': 'The Sydney Harbour Bridge took 8 years to build and was completed in 1932.',
            'Berlin, Germany': 'Berlin has more bridges than Venice - over 1,700 of them!',
            'Rome, Italy': 'The Trevi Fountain collects about â‚¬3,000 in coins every day!'
          };
          this.context['ai-funfact'] = funFacts[city] || `${city} has a fascinating history!`;
          console.log('ðŸŽ­ Simulated fun fact:', this.context['ai-funfact']);
        }

        console.log('ðŸŽ¯ Final context after all AI processing:', this.context);
      },

      updateNavButtons() {
        const homeBtn = document.getElementById('homeBtn');
        const prevBtn = document.getElementById('prevBtn');
        const nextBtn = document.getElementById('nextBtn');

        // Check if wizard is initialized (has views)
        if (!this.views || this.views.length === 0) {
          // Initial state - show Next button that starts the script
          homeBtn.disabled = true;
          homeBtn.style.opacity = '0.5';
          prevBtn.disabled = true;
          prevBtn.style.opacity = '0.5';
          nextBtn.innerHTML = 'Next <i data-lucide="chevron-right"></i>';
          nextBtn.className = '';
          nextBtn.onclick = () => runScript();
          lucide.createIcons();
          return;
        }

        // Home button - disabled on first step
        if (this.currentStep === 0) {
          homeBtn.disabled = true;
          homeBtn.style.opacity = '0.5';
        } else {
          homeBtn.disabled = false;
          homeBtn.style.opacity = '1';
        }

        // Back button - disabled on first step
        if (this.currentStep === 0) {
          prevBtn.disabled = true;
          prevBtn.style.opacity = '0.5';
        } else {
          prevBtn.disabled = false;
          prevBtn.style.opacity = '1';
        }

        // Forward/Restart button
        if (this.currentStep === this.views.length - 1) {
          nextBtn.innerHTML = '<i data-lucide="refresh-cw"></i> Restart';
          nextBtn.className = 'contrast';
          nextBtn.onclick = async () => {
            await this.generateAI();
            this.goto(0);
          };
        } else {
          nextBtn.innerHTML = ' <i data-lucide="chevron-right"></i>  Next';
          nextBtn.className = '';
          nextBtn.onclick = () => this.next();
        }

        // Re-initialize icons after button updates
        lucide.createIcons();
      },

      capitalize(str) {
        return str.charAt(0).toUpperCase() + str.slice(1);
      }
    };

    function runScript() {
      try {
        wizard.init(defaultScript);
        // The first view will be displayed automatically by init()
      } catch (error) {
        console.error('Run script error:', error);
        alert('Error running script: ' + error.message);
      }
    }

    // Initialize Lucide icons on page load
    document.addEventListener('DOMContentLoaded', () => {
      lucide.createIcons();
      initializeModals();
      initializeThemeSwitcher();
      loadSettings();
      wizard.updateNavButtons(); // Set up initial button state
      runScript(); // Automatically start the script to show first view
    });

    // PicoCSS Theme Switcher
    function initializeThemeSwitcher() {
      // Get saved theme or default to 'auto'
      const savedTheme = localStorage.getItem('theme') || 'auto';

      // Apply saved theme
      document.documentElement.setAttribute('data-theme', savedTheme);

      // Handle theme switcher clicks
      document.querySelectorAll('[data-theme-switcher]').forEach(button => {
        button.addEventListener('click', (e) => {
          e.preventDefault();
          const theme = button.getAttribute('data-theme-switcher');

          // Set theme
          document.documentElement.setAttribute('data-theme', theme);

          // Save to localStorage
          localStorage.setItem('theme', theme);

          // Close dropdown
          const dropdown = button.closest('details');
          if (dropdown) {
            dropdown.removeAttribute('open');
          }
        });
      });

      // Listen for system theme changes in auto mode
      window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', () => {
        const currentTheme = localStorage.getItem('theme') || 'auto';
        if (currentTheme === 'auto') {
          document.documentElement.setAttribute('data-theme', 'auto');
        }
      });
    }

    // Modal functionality
    function initializeModals() {
      const helpLink = document.getElementById('helpLink');
      const settingsLink = document.getElementById('settingsLink');
      const helpModal = document.getElementById('helpModal');
      const settingsModal = document.getElementById('settingsModal');

      // Function to open a modal
      const openModal = (modal) => {
        modal.setAttribute('open', '');
        document.documentElement.classList.add('modal-is-open');
      };

      // Function to close a modal
      const closeModal = (modal) => {
        modal.removeAttribute('open');
        document.documentElement.classList.remove('modal-is-open');
      };

      // Event listeners for opening modals
      if (helpLink && helpModal) {
        helpLink.addEventListener('click', (event) => {
          event.preventDefault();
          // Check if help content is available, if not show a message
          const helpContent = document.getElementById('helpContent');
          if (helpContent && helpContent.innerHTML.includes('Loading help content')) {
            helpContent.innerHTML = '<p><em>Please start the quiz first to load help content from the script.</em></p>';
          }
          openModal(helpModal);
        });
      }

      if (settingsLink && settingsModal) {
        settingsLink.addEventListener('click', (event) => {
          event.preventDefault();
          openModal(settingsModal);
        });
      }

      // Event listeners for closing modals
      document.querySelectorAll('dialog button[rel="prev"]').forEach((button) => {
        button.addEventListener('click', (event) => {
          const modal = button.closest('dialog');
          closeModal(modal);
        });
      });

      // Close modal when clicking outside of it
      document.querySelectorAll('dialog').forEach((modal) => {
        modal.addEventListener('click', (event) => {
          if (event.target === modal) {
            closeModal(modal);
          }
        });
      });

      // Close modal with Escape key
      document.addEventListener('keydown', (event) => {
        if (event.key === 'Escape') {
          const openModal = document.querySelector('dialog[open]');
          if (openModal) {
            closeModal(openModal);
          }
        }
      });
    }

    // Settings functions
    function saveSettings() {
      const useSimulatedAI = document.getElementById('useSimulatedAI').checked;
      const showDebugInfo = document.getElementById('showDebugInfo').checked;
      const autoAdvance = document.getElementById('autoAdvance').value === 'true';

      // Store settings in localStorage
      localStorage.setItem('aiQuizSettings', JSON.stringify({
        useSimulatedAI,
        showDebugInfo,
        autoAdvance
      }));

      // Close the modal
      const settingsModal = document.getElementById('settingsModal');
      settingsModal.removeAttribute('open');
      document.documentElement.classList.remove('modal-is-open');

      // Show confirmation
      alert('Settings saved successfully!');
    }

    function resetSettings() {
      // Reset form to defaults
      document.getElementById('useSimulatedAI').checked = true;
      document.getElementById('showDebugInfo').checked = false;
      document.getElementById('autoAdvance').value = 'false';

      // Clear localStorage
      localStorage.removeItem('aiQuizSettings');

      alert('Settings reset to defaults!');
    }

    function loadSettings() {
      const savedSettings = localStorage.getItem('aiQuizSettings');
      if (savedSettings) {
        const settings = JSON.parse(savedSettings);
        document.getElementById('useSimulatedAI').checked = settings.useSimulatedAI;
        document.getElementById('showDebugInfo').checked = settings.showDebugInfo;
        document.getElementById('autoAdvance').value = settings.autoAdvance ? 'true' : 'false';
      }
    }
  </script>
</body>

</html>