<!DOCTYPE html>

<html lang="en" data-aiweb-format="AI.Web" data-aiweb-version="1.0">

<head>
  <meta charset="utf-8" />
  <title>AI.Web + AI.Web.Script ‚Äî Minimal Cities Quiz</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@2/css/pico.min.css">
  <style>
    .app {
      max-width: 780px;
      margin: 2rem auto;
    }

```
textarea#aiweb-script {
  width: 100%;
  height: 240px;
}

.hidden {
  display: none;
}

.ai-thinking {
  opacity: 0.6;
  font-style: italic;
}

.error {
  color: red;
  background: #fee;
  padding: 1rem;
  border-radius: 4px;
  margin: 1rem 0;
}
```

  </style>
</head>

<body>
  <main class="container app">

```
<h1>üèôÔ∏è Minimal Cities Quiz (AI.Web + AI.Web.Script)</h1>

<!-- API key -->
<article>
  <label>
    Groq API Key (starts with <code>gsk_</code>)
    <input type="text" id="apiKey" placeholder="gsk_..." />
  </label>
</article>

<!-- AI.Web.Script editor -->
<article>
  <header><strong>AI.Web.Script</strong> (edit &amp; press Run)</header>
  <textarea id="aiweb-script" spellcheck="false">
```

// AI.Web.Script - Natural language instructions for AI to interpret
// The AI will read this entire script and execute the flow

title: Cities Quiz
author: J. Smith

// === Templates ===
// Templates contain instructions for AI to follow when rendering

template: start.template
Greet the user warmly and introduce them to ::title.value:: by ::author.value::.
Use a wave emoji and make it friendly.

Then, pick a random city from data.cities below.
Ask the user to tell you 3 things they know about that city.
Include the appropriate country flag emoji for the city.
Make the question engaging and encouraging.

IMPORTANT: At the very end of your response, add this hidden marker:

<!-- CITY: [the city you picked] -->

template: reply.template
The user was asked about: ::selected_city.value::
The user answered: ::user_answer.value::

Now do the following:

1. Grade their answer from A to F based on accuracy, completeness (3 things?), and detail
1. Be encouraging - even basic knowledge deserves at least a C
1. Display the grade in a nice format with an appropriate emoji
1. Share one surprising or little-known historical fact about ::selected_city.value::
1. Format everything in clean, readable markdown

template: goodbye.template
Thank the user for playing ::title.value::.
Wish them well and use a friendly wave emoji.

// === Data section ===
data:
cities:
- London, England
- New York City, USA
- Toronto, Canada
- Washington, D.C., USA
- Ottawa, Canada
- Paris, France
- Tokyo, Japan
- Sydney, Australia
- Berlin, Germany
- Rome, Italy
</textarea>
<div class="grid">
<button id="runBtn">Run</button>
<button class="secondary" id="resetBtn">Reset</button>
</div>
</article>

```
<!-- App surface -->
<article id="stage">
  <p class="hidden" id="hint">Ready.</p>
  <div id="view"></div>
  <form id="answerForm" class="hidden">
    <label>Your answer
      <textarea id="answer" rows="4" placeholder="Write 2‚Äì3 short lines‚Ä¶"></textarea>
    </label>
    <button type="submit">Submit</button>
  </form>
  <div id="actions" class="hidden">
    <button id="againBtn" class="secondary">Try another city</button>
    <button id="quitBtn" class="contrast">Quit</button>
  </div>
</article>
```

  </main>

  <script src="https://cdn.jsdelivr.net/npm/marked@11.1.1/marked.min.js"></script>

  <script>
    /* =======================
       0) Tiny helpers
    ======================= */
    const $ = sel => document.querySelector(sel);
    const md = (text) => marked.parse(text || "");

    /* =======================
       1) AI.Web.Script parser (simple)
       Just extract metadata, templates, and data
       AI will do all the interpretation and rendering
    ======================= */
    function parseAIWebScript(src) {
      const lines = src.replace(/\r\n/g, "\n").split("\n");

      const meta = {};
      const templates = {};
      const data = {};
      let i = 0;

      // Pass 1: metadata until blank or template:/data:
      while (i < lines.length) {
        const line = lines[i].trim();
        if (!line) { i++; break; }
        if (/^(template:|data:)/i.test(line)) break;
        if (/^\/\//.test(line) || /^\/\*/.test(line)) { i++; continue; }
        const m = line.match(/^([\w.-]+)\s*:\s*(.*)$/);
        if (m) meta[m[1].trim()] = m[2].trim();
        i++;
      }

      // Pass 2: templates and data
      let currentTpl = null, buf = [];
      for (; i < lines.length; i++) {
        const raw = lines[i];
        const line = raw.trim();

        if (/^template:\s*/i.test(line)) {
          if (currentTpl) templates[currentTpl] = buf.join("\n").trim();
          currentTpl = line.replace(/^template:\s*/i, "");
          buf = [];
          continue;
        }

        if (/^data:\s*$/i.test(line)) {
          if (currentTpl) { templates[currentTpl] = buf.join("\n").trim(); currentTpl = null; buf = []; }
          i++;
          while (i < lines.length) {
            const draw = lines[i];
            const dline = draw.replace(/\t/g, '    ');
            const trimmed = draw.trim();

            if (!trimmed) { i++; continue; }
            if (/^template:\s*/i.test(trimmed)) { i--; break; }
            if (!/^(\s|#)/.test(draw)) { i--; break; }
            if (trimmed.startsWith('#')) { i++; continue; }

            const keyMatch = dline.match(/^\s{2}([\w.-]+):\s*$/);
            if (keyMatch) {
              const key = keyMatch[1];
              const arr = [];
              i++;
              while (i < lines.length) {
                const lraw = lines[i];
                const ltrim = lraw.trim();
                if (!ltrim) { i++; continue; }
                if (ltrim.startsWith('#')) { i++; continue; }
                if (/^\s{2}[\w.-]+:\s*$/.test(lraw) || !/^\s/.test(lraw)) { i--; break; }
                const itemMatch = lraw.match(/^\s{4}-\s+(.*)$/);
                if (itemMatch) {
                  arr.push(itemMatch[1].trim());
                  i++;
                  continue;
                } else {
                  i--; break;
                }
              }
              data[key] = arr.length ? arr : data[key] || [];
            }
            i++;
          }
          continue;
        }

        if (currentTpl !== null) buf.push(raw);
      }
      if (currentTpl) templates[currentTpl] = buf.join("\n").trim();

      return { meta, templates, data };
    }

    /* =======================
       2) AI Interpreter - The Magic Happens Here
       Send the entire script context to AI with a "super prompt"
       AI interprets and renders everything
    ======================= */
    async function renderTemplateWithAI(templateName, ctx, apiKey) {
      if (!apiKey || !apiKey.startsWith("gsk_")) {
        return { html: `<p class="error">‚ö†Ô∏è Valid Groq API key required (starts with gsk_)</p>`, city: null };
      }

      // Build the super prompt that makes AI the interpreter
      const superPrompt = buildSuperPrompt(templateName, ctx);

      console.log("Calling AI with prompt:", superPrompt.substring(0, 200) + "...");

      try {
        const response = await fetch("https://api.groq.com/openai/v1/chat/completions", {
          method: "POST",
          headers: {
            "Authorization": `Bearer ${apiKey}`,
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            model: "llama-3.1-8b-instant",
            messages: [
              {
                role: "system",
                content: "You are an AI.Web.Script interpreter. You read scripts with natural language instructions and render them into clean HTML. Follow all instructions precisely. Use markdown formatting. Be creative and helpful."
              },
              {
                role: "user",
                content: superPrompt
              }
            ],
            temperature: 0.7,
            max_tokens: 1000
          })
        });

        if (!response.ok) {
          const errorText = await response.text();
          console.error("API Error:", response.status, errorText);
          throw new Error(`API returned ${response.status}: ${errorText}`);
        }

        const result = await response.json();
        console.log("AI Response:", result);
        
        const content = result?.choices?.[0]?.message?.content;
        
        if (!content) {
          throw new Error("No content in AI response");
        }

        // Extract city if AI embedded it
        const cityMatch = content.match(/<!--\s*CITY:\s*([^-]+)\s*-->/);
        const city = cityMatch ? cityMatch[1].trim() : null;
        const html = content.replace(/<!--\s*CITY:[^-]+-->/, '');
        
        return { html, city };

      } catch (error) {
        console.error("Error calling AI:", error);
        return { 
          html: `<div class="error">‚ö†Ô∏è Error calling AI: ${error.message}<br><br>Please check:<br>1. Your API key is correct<br>2. You have API credits<br>3. Your internet connection</div>`,
          city: null 
        };
      }
    }

    function buildSuperPrompt(templateName, ctx) {
      const template = ctx.templates[templateName] || "";
      
      let contextSection = "";
      if (ctx.userAnswer) {
        contextSection += `- User's answer: "${ctx.userAnswer}"\n`;
      }
      if (ctx.selectedCity) {
        contextSection += `- Selected city: ${ctx.selectedCity}\n`;
      }
      if (!contextSection) {
        contextSection = "- No user interaction yet\n";
      }

      return `You are interpreting an AI.Web.Script application.

SCRIPT METADATA:
${Object.entries(ctx.meta).map(([k, v]) => `${k}: ${v}`).join('\n')}

AVAILABLE DATA:
${Object.entries(ctx.data).map(([k, v]) => `${k}: ${JSON.stringify(v)}`).join('\n')}

CURRENT CONTEXT:
${contextSection}

TEMPLATE TO RENDER: ${templateName}
----------------------------------------
${template}
----------------------------------------

YOUR TASK:
Read the template instructions above and render them into clean, well-formatted HTML/Markdown.

CRITICAL RULES FOR TOKEN REPLACEMENT:
1. Replace ::title.value:: with exactly: ${ctx.meta.title || 'Cities Quiz'}
2. Replace ::author.value:: with exactly: ${ctx.meta.author || 'J. Smith'}
3. Replace ::user_answer.value:: with exactly: ${ctx.userAnswer || '(no answer yet)'}
4. Replace ::selected_city.value:: with exactly: ${ctx.selectedCity || '(no city selected)'}
5. When you see "Pick a random city from data.cities", choose ONE city from this list: ${JSON.stringify(ctx.data.cities)}
6. DO NOT use array notation like ::data.cities[0]:: - just write the actual city name you chose
7. When you pick a city, use its actual name in your response (e.g., "Paris, France" not "::data.cities[0]::")

OTHER RULES:
- Follow ALL natural language instructions in the template carefully
- Use proper HTML/Markdown formatting
- Be warm, engaging, and helpful in tone
- If you select a random city, include this hidden marker at the very end: <!-- CITY: [the city you picked] -->

Return ONLY the rendered HTML/Markdown content with all tokens properly replaced.`;
    }

    /* =======================
       3) Application Flow
       Much simpler now - just call AI to render each state
    ======================= */
    const state = { 
      ctx: null, 
      apiKey: "", 
      userAnswer: "",
      selectedCity: null
    };

    async function runScript() {
      state.apiKey = $("#apiKey").value.trim();
      if (!state.apiKey.startsWith("gsk_")) {
        alert("Please enter a valid Groq API key (starts with gsk_)");
        return;
      }

      state.ctx = parseAIWebScript($("#aiweb-script").value);
      state.ctx.userAnswer = "";
      state.ctx.selectedCity = null;

      $("#view").innerHTML = '<p class="ai-thinking">ü§ñ AI is rendering your app...</p>';
      $("#answerForm").classList.add("hidden");
      $("#actions").classList.add("hidden");

      // Render start template (combines hello + ask)
      const result = await renderTemplateWithAI("start.template", state.ctx, state.apiKey);
      
      if (result.city) {
        state.selectedCity = result.city;
        state.ctx.selectedCity = result.city;
      }
      
      $("#view").innerHTML = md(result.html);
      $("#answerForm").classList.remove("hidden");
      $("#hint").classList.add("hidden");
      $("#answer").focus();
    }

    async function handleSubmit(e) {
      e.preventDefault();
      const userText = $("#answer").value.trim();
      if (!userText) return;

      state.ctx.userAnswer = userText;
      state.userAnswer = userText;

      $("#view").innerHTML = '<p class="ai-thinking">ü§ñ AI is reading your answer and preparing feedback...</p>';
      $("#answerForm").classList.add("hidden");

      // AI renders the reply with grading and fun fact
      const result = await renderTemplateWithAI("reply.template", state.ctx, state.apiKey);
      $("#view").innerHTML = md(result.html);

      $("#actions").classList.remove("hidden");
    }

    async function again() {
      state.ctx.userAnswer = "";
      state.ctx.selectedCity = null;
      
      $("#view").innerHTML = '<p class="ai-thinking">ü§ñ Picking a new city...</p>';
      $("#answerForm").classList.add("hidden");
      $("#actions").classList.add("hidden");

      const result = await renderTemplateWithAI("start.template", state.ctx, state.apiKey);
      
      if (result.city) {
        state.selectedCity = result.city;
        state.ctx.selectedCity = result.city;
      }
      
      $("#view").innerHTML = md(result.html);
      $("#answer").value = "";
      $("#answerForm").classList.remove("hidden");
      $("#answer").focus();
    }

    async function quit() {
      $("#view").innerHTML = '<p class="ai-thinking">ü§ñ AI is saying goodbye...</p>';
      
      const result = await renderTemplateWithAI("goodbye.template", state.ctx, state.apiKey);
      $("#view").innerHTML = md(result.html);
      
      $("#answerForm").classList.add("hidden");
      $("#actions").classList.add("hidden");
    }

    /* =======================
       4) Wire up
    ======================= */
    $("#runBtn").addEventListener("click", runScript);
    $("#resetBtn").addEventListener("click", () => {
      $("#view").innerHTML = "";
      $("#answer").value = "";
      $("#hint").classList.remove("hidden");
      $("#answerForm").classList.add("hidden");
      $("#actions").classList.add("hidden");
    });
    $("#answerForm").addEventListener("submit", handleSubmit);
    $("#againBtn").addEventListener("click", again);
    $("#quitBtn").addEventListener("click", quit);
  </script>

</body>

</html>