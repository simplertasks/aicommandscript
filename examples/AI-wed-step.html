<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>AI.Web.Script Wizard</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@2/css/pico.min.css" />
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <!-- Lucide Icons -->
  <script src="https://unpkg.com/lucide@latest"></script>
  <style>
    .progress-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: .75rem;
      margin-bottom: 0.5rem;
    }
    .progress-header h2 {
      margin: 0;
      font-size: 1rem;
      display: inline-flex;
      gap: .5rem;
      align-items: center;
    }
    .button-group {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 1rem;
    }
    .step-content { display: none; }
    .step-content.active { display: block; }

    i[data-lucide] { width: 18px; height: 18px; vertical-align: middle; }
    .button-group button i[data-lucide]:first-child { margin-right: .25rem; }
    .button-group button i[data-lucide]:last-child { margin-left: .25rem; }

    details.dropdown summary {
      display: inline-flex;
      align-items: center;
      gap: .4rem;
      cursor: pointer;
    }
    #step-menu li a[aria-current="step"] { font-weight: 600; }
  </style>
</head>
<body>
  <div class="progress-indicator">
    <div class="container">
      <div class="progress-header">
        <h2 id="step-title"><i data-lucide="map-pin" aria-hidden="true"></i></h2>

        <!-- Pico dropdown for step navigation -->
        <details class="dropdown" id="step-dropdown">
          <summary id="step-summary">
            <i data-lucide="list-ordered" aria-hidden="true"></i>
            Steps
          </summary>
          <ul id="step-menu"></ul>
        </details>
      </div>

      <progress id="interactive-progress" value="1" max="1"></progress>
    </div>
  </div>

  <main class="container" id="main-content"></main>

  <div class="container">
    <div class="button-group">
      <button id="home-btn" class="secondary home-btn">
        <i data-lucide="home"></i>
        Home
      </button>
      <button id="back-btn" class="secondary back-btn">
        <i data-lucide="arrow-left"></i>
        Back
      </button>
      <button id="next-btn" class="next-btn">
        Next
        <i data-lucide="arrow-right"></i>
      </button>
    </div>
  </div>

  <!-- AI.Web.Script -->
  <script type="text/ai-web-script">
METADATA
title: Cities Quiz
author: J. Smith
description: A simple quiz testing knowledge of cities.

AI-GENERATED
ai-selected-city: randomly select one city from {cities}
ai-evaluation: evaluate {city-facts} for accuracy and completeness
ai-grade: assign grade A-F with brief explanation
ai-funfact: generate interesting fact about {ai-selected-city}

VIEWS
<view name="input">

# Welcome to {title} by {author}

{description}

<form>
  <label>Please enter your name
    <input type="text" name="user-name" placeholder="Your name" />
  </label>

<label>What are three facts about {ai-selected-city}?
<textarea name="city-facts" rows="4" placeholder="Enter three facts..."></textarea>
</label>

</form>
</view>

<view name="output">
**Hello {user-name}!**

You were asked about **{ai-selected-city}** and you replied:

*{city-facts}*

## AI Evaluation

{ai-evaluation}

**Grade: {ai-grade}**

## Fun Fact

*{ai-funfact}*
</view>

<view name="goodbye">
## Thanks for playing {title}!

By the way, the other cities were:

{cities}

> Goodbye
</view>

DATA
cities:

- London, England
- New York City, USA
- Toronto, Canada
- Washington, D.C., USA
- Ottawa, Canada
- Paris, France
- Tokyo, Japan
- Sydney, Australia
- Berlin, Germany
- Rome, Italy
  </script>

  <script>
    // -------------------------------
    // Parser for AI.Web.Script format
    // -------------------------------
    class AIWebScriptParser {
      parse(scriptContent) {
        const sections = this.splitIntoSections(scriptContent);
        return {
          metadata: this.parseKeyValue(sections.METADATA || ''),
          aiGenerated: this.parseKeyValue(sections['AI-GENERATED'] || ''),
          views: this.parseViews(sections.VIEWS || ''),
          data: this.parseData(sections.DATA || '')
        };
      }
      splitIntoSections(content) {
        const sections = {};
        const sectionRegex = /^([A-Z\-]+)\s*$/gm;
        const parts = content.split(sectionRegex).filter(s => s.trim());
        for (let i = 0; i < parts.length; i += 2) {
          if (parts[i] && parts[i + 1]) sections[parts[i].trim()] = parts[i + 1].trim();
        }
        return sections;
      }
      parseKeyValue(content) {
        const result = {};
        const lines = content.split('\n');
        for (const line of lines) {
          const match = line.match(/^([^:]+):\s*(.+)$/);
          if (match) result[match[1].trim()] = match[2].trim();
        }
        return result;
      }
      parseViews(content) {
        const views = {};
        const viewRegex = /<view name="([^"]+)">([\s\S]*?)<\/view>/g;
        let match;
        while ((match = viewRegex.exec(content)) !== null) {
          views[match[1]] = { name: match[1], content: match[2].trim() };
        }
        return views;
      }
      parseData(content) {
        const result = {};
        const lines = content.split('\n');
        let currentKey = null;
        let currentArray = [];
        for (const line of lines) {
          if (line.match(/^([^:]+):$/)) {
            if (currentKey) result[currentKey] = currentArray;
            currentKey = line.replace(':', '').trim();
            currentArray = [];
          } else if (line.trim().startsWith('-')) {
            currentArray.push(line.trim().substring(1).trim());
          }
        }
        if (currentKey) result[currentKey] = currentArray;
        return result;
      }
    }

    // -------------------------------
    // Application state
    // -------------------------------
    let parsedScript = null;
    let currentStep = 1;
    let formData = {};   // <-- plain JS object holding form values
    let aiData = {};
    let stepsCache = null;

    // -------------------------------
    // Helpers
    // -------------------------------
    function refreshIcons() {
      if (window.lucide && typeof lucide.createIcons === 'function') {
        lucide.createIcons();
      }
    }

    function buildSteps() {
      const viewNames = Object.keys(parsedScript.views || {});
      return viewNames.map((name, index) => ({
        id: index + 1,
        name: name.charAt(0).toUpperCase() + name.slice(1),
        viewName: name
      }));
    }

    function getSteps(force = false) {
      if (force || !stepsCache) stepsCache = buildSteps();
      return stepsCache;
    }

    // Re-apply saved values to inputs/textareas after each render
    function restoreFormValues(root = document) {
      const fields = root.querySelectorAll('input[name], textarea[name], select[name]');
      fields.forEach(el => {
        const key = el.name;
        if (key in formData) {
          // Support input/textarea/select
          if (el.tagName === 'INPUT' || el.tagName === 'TEXTAREA' || el.tagName === 'SELECT') {
            el.value = formData[key];
          }
        }
      });
    }

    // -------------------------------
    // Init
    // -------------------------------
    function init() {
      const scriptElement = document.querySelector('script[type="text/ai-web-script"]');
      if (!scriptElement) return console.error('No AI.Web.Script found');

      const parser = new AIWebScriptParser();
      parsedScript = parser.parse(scriptElement.textContent);
      stepsCache = null; // invalidate cache

      generateAIData();
      renderWizard();
      renderStepMenu();
      updateUI();
      attachEventListeners();
      restoreFormValues(document);  // <-- ensure fields are repopulated on first render
      refreshIcons();
    }

    // Simulated AI generation
    function generateAIData() {
      if (parsedScript.data.cities?.length) {
        const randomCity = parsedScript.data.cities[
          Math.floor(Math.random() * parsedScript.data.cities.length)
        ];
        aiData['ai-selected-city'] = randomCity;
      }
      aiData['ai-evaluation'] = 'Your facts show good knowledge of the city. Some details could be more specific.';
      aiData['ai-grade'] = 'B+ - Good effort with room for improvement';
      aiData['ai-funfact'] = `Did you know that ${aiData['ai-selected-city']} has a fascinating history dating back centuries?`;
    }

    // -------------------------------
    // Rendering
    // -------------------------------
    function interpolateVariables(content) {
      let result = content;

      // Metadata
      for (const [key, value] of Object.entries(parsedScript.metadata))
        result = result.replace(new RegExp(`\\{${key}\\}`, 'g'), value);

      // Data (arrays -> simple numbered text list)
      for (const [key, value] of Object.entries(parsedScript.data)) {
        if (Array.isArray(value)) {
          const listText = value.map((item, i) => `${i + 1}. ${item}`).join('\n');
          result = result.replace(new RegExp(`\\{${key}\\}`, 'g'), listText);
        } else {
          result = result.replace(new RegExp(`\\{${key}\\}`, 'g'), value);
        }
      }

      // AI-generated
      for (const [key, value] of Object.entries(aiData))
        result = result.replace(new RegExp(`\\{${key}\\}`, 'g'), value);

      // Form data
      for (const [key, value] of Object.entries(formData))
        result = result.replace(new RegExp(`\\{${key}\\}`, 'g'), value || '[not provided]');

      return result;
    }

    function renderWizard() {
      const steps = getSteps();
      const mainContent = document.getElementById('main-content');

      mainContent.innerHTML = steps.map(step => {
        const view = parsedScript.views[step.viewName];
        const interpolated = interpolateVariables(view.content);
        const html = marked.parse(interpolated);
        return `<div id="step-${step.id}" class="step-content" data-step="${step.id}">${html}</div>`;
      }).join('');

      // After rendering, restore any saved form values into the DOM
      restoreFormValues(mainContent);
      refreshIcons();
    }

    function renderStepMenu() {
      const steps = getSteps();
      const menu = document.getElementById('step-menu');
      menu.innerHTML = steps.map(step => `
        <li><a href="#" data-step="${step.id}">${step.id}/${steps.length} - ${step.name}</a></li>
      `).join('');
    }

    // -------------------------------
    // Events
    // -------------------------------
    function attachEventListeners() {
      document.getElementById('home-btn').addEventListener('click', () => goToStep(1));
      document.getElementById('back-btn').addEventListener('click', previousStep);
      document.getElementById('next-btn').addEventListener('click', nextStep);

      // Step dropdown click -> navigate
      document.getElementById('step-menu').addEventListener('click', (e) => {
        const link = e.target.closest('a[data-step]');
        if (!link) return;
        e.preventDefault();
        const stepId = parseInt(link.dataset.step, 10);
        goToStep(stepId);
        document.getElementById('step-dropdown').removeAttribute('open'); // close Pico dropdown
      });

      // Track form input live into formData
      document.addEventListener('input', (e) => {
        const t = e.target;
        if (t && t.name) {
          // For inputs/textarea/select
          formData[t.name] = t.value;
        }
      });
      // Also catch change (helps with select/radio if added later)
      document.addEventListener('change', (e) => {
        const t = e.target;
        if (t && t.name) {
          formData[t.name] = t.value;
        }
      });
    }

    // -------------------------------
    // Navigation
    // -------------------------------
    function goToStep(stepId) {
      const steps = getSteps();
      if (stepId >= 1 && stepId <= steps.length) {
        currentStep = stepId;

        // Re-render content so interpolations appear in output view
        renderWizard();
        renderStepMenu();
        updateUI();
        attachEventListeners();          // rebind after innerHTML updates
        restoreFormValues(document);     // <-- re-apply saved values after each navigation
        refreshIcons();
      }
    }

    function previousStep() {
      if (currentStep > 1) goToStep(currentStep - 1);
    }

    function nextStep() {
      const steps = getSteps();
      if (currentStep < steps.length) goToStep(currentStep + 1);
    }

    // -------------------------------
    // UI update (simplified text updates)
    // -------------------------------
    function updateUI() {
      const steps = getSteps();
      const maxSteps = steps.length;
      const currentStepData = steps[currentStep - 1];

      // Progress
      const progressEl = document.getElementById('interactive-progress');
      progressEl.value = currentStep;
      progressEl.max = maxSteps;

      // Title text (preserve icon)
      const stepTitle = document.getElementById('step-title');
      const titleIcon = stepTitle.querySelector('i[data-lucide]');
      stepTitle.textContent = `${currentStep}. ${currentStepData.name}`;
      if (titleIcon) stepTitle.prepend(titleIcon);

      // Dropdown summary text (preserve icon)
      const summary = document.getElementById('step-summary');
      const summaryIcon = summary.querySelector('i[data-lucide]');
      summary.textContent = `${currentStep}/${maxSteps} - ${currentStepData.name}`;
      if (summaryIcon) summary.prepend(summaryIcon);

      // Show active step content
      document.querySelectorAll('.step-content').forEach(article => {
        const stepId = parseInt(article.dataset.step, 10);
        article.classList.toggle('active', stepId === currentStep);
      });

      // Highlight current item in dropdown
      document.querySelectorAll('#step-menu a[data-step]').forEach(a => {
        const stepId = parseInt(a.dataset.step, 10);
        a.toggleAttribute('aria-current', stepId === currentStep);
      });

      // Buttons
      document.getElementById('back-btn').disabled = currentStep === 1;
      document.getElementById('next-btn').disabled = currentStep === maxSteps;

      refreshIcons();
    }

    // -------------------------------
    // Start the application
    // -------------------------------
    init();

    // (Optional) If you want the raw JSON string at any time:
    // const jsonString = JSON.stringify(formData);
  </script>
</body>
</html>